# -*- coding: utf-8 -*-
"""Gradient_Descent.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OXj7Qs62h86luoCwZK7zHclgJVc0ntvu
"""

# Libraries
from matplotlib import cm # Handles colors
import matplotlib.pyplot as plt # Library for graphs
import numpy as np # Library for vectors and math utilities

"""## 3D Graph of Cost Function"""

fig, ax = plt.subplots(subplot_kw={"projection": "3d"})

def f(x,y):
  return x**2 + y**2;

res = 100

X = np.linspace(-4, 4, res)
Y = np.linspace(-4, 4, res)

X, Y = np.meshgrid(X, Y)

Z = f(X,Y) 

# Plot the surface
surf = ax.plot_surface(X, Y, Z, cmap=cm.cool,
                       linewidth=0, antialiased=False)

fig.colorbar(surf)

"""## Gradient Descent"""

level_map = np.linspace(np.min(Z), np.max(Z),res) 
plt.contourf(X, Y, Z, levels=level_map,cmap=cm.cool)
plt.colorbar()
plt.title('Gradient Descent')

def derivate(_p,p):
  return  (f(_p[0],_p[1]) - f(p[0],p[1])) / h

p = np.random.rand(2) * 8 - 4 # Generates 2 random values

plt.plot(p[0],p[1],'o', c='k')

lr = 0.01
h = 0.01

grad = np.zeros(2)

for i in range(10000):
  for idx, val in enumerate(p): 
    _p = np.copy(p)

    _p[idx] = _p[idx] + h;

    dp = derivate(_p,p) 

    grad[idx] = dp

  p = p - lr * grad

  if(i % 10 == 0):
    plt.plot(p[0],p[1],'o', c='r')

plt.plot(p[0],p[1],'o', c='w')
plt.show()

print("The highest point is in: ", p)